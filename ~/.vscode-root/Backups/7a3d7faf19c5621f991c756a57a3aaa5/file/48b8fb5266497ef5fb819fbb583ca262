file:///root/js/soul-reserve/index.html
<html>
	<head>
		<title>Soul Sphere</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>

	</head>
	<body>
		<script src="engine/three.js"></script>
		<script>
			let RUNNING_INDEXES = [-1];
			let AVATARS = [];
			

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 100, window.innerWidth/window.innerHeight, 0.1, 1000 );

			var raycaster = new THREE.Raycaster(), intersected =null;
			raycaster.params.Points.threshold = 0.015;

			var renderer;

			var mouse = new THREE.Vector2();

			// camera.position.x = 2
			// camera.position.y = 2
			// camera.position.z = 2

			function onMouseMove( event ) {

			// calculate mouse position in normalized device coordinates
			// (-1 to +1) for both components

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
			}

			ConvertToWorld = (index) => pointsClouds.geometry.vertices[index].clone().applyMatrix4(pointsClouds.matrixWorld);
			
			RemoveAvatar =(object)=>{ 
				var selectedObject = scene.getObjectByName(object.name);
				scene.remove( selectedObject );
				// animate(); 
			};

			var renderer = new THREE.WebGLRenderer({ antialias : true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			//light
			var lights = [];
			lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[ 0 ].position.set( 0, 200, 0 );
			scene.add( lights[ 0 ] );

			//blackGeo
			var geometry = new THREE.IcosahedronGeometry( 1.97, 3 );
			var meshMaterial = new THREE.MeshBasicMaterial( { color: 'black' } );
			var mesh = new THREE.Mesh( geometry, meshMaterial );

			//wireFrame
			var lineMat = new THREE.LineBasicMaterial({ color: 'white' })
			var geometryWire = new THREE.IcosahedronBufferGeometry( 2, 3 );
			var wireframe = new THREE.WireframeGeometry( geometryWire );
			var line = new THREE.LineSegments( wireframe, lineMat );
			line.material.opacity = 1;
			line.material.transparent = true;

			//points setup
			
			var pointGeo = new THREE.IcosahedronGeometry( 3.5, 4 )
			var pointMat = new THREE.PointsMaterial({ color : 'white', size : 0.04 });

			pointGeo.vertices.forEach(function(vertex) { 
				vertex.x += (Math.random() - 0.5);
				vertex.y += (Math.random() - 0.5);
				vertex.z += (Math.random() - 0.5);
			 })

			var pointsClouds = new THREE.Points( pointGeo, pointMat );
			
			pC =[pointsClouds];


		

			// console.log(pointsClouds)


			scene.add(line,mesh,pointsClouds );

			camera.position.z = 5;

			document.addEventListener( 'mousemove', onMouseMove, false );


			animate();

			function animate(){

				requestAnimationFrame( animate );

				render();

				
			

				mesh.rotation.x += 0.001;
				mesh.rotation.y += 0.001;

				line.rotation.x += 0.001;
				line.rotation.y += 0.001;

			

				// pointsClouds.geometry.vertices.forEach(function(particle) {
				// 	particle.x += (Math.random() / 500)-(Math.random() / 500);
				// 	particle.y += (Math.random() / 500)-(Math.random() / 500);
				// 	particle.z += (Math.random() / 500)-(Math.random() / 500);
				// } )

				pointsClouds.rotation.x += 0.001;
				pointsClouds.rotation.y += 0.001;

				pointsClouds.geometry.verticesNeedUpdate = true;
				pointsClouds.matrixAutoUpdate = true;
				pointsClouds.updateMatrix();

				// plane.position.set(pointsClouds.geometry.faceVertexUvs[0].x,pointsClouds.geometry.faceVertexUvs[0].y,pointsClouds.geometry.faceVertexUvs[0].z)
				


			}
	

			class PlaneAvatar {
				
				constructor(index) {

					this.index = index;
					this.plane_geometry = new THREE.PlaneGeometry( 0.8, 0.8, 1 );
					this.plane_material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
					this.plane = new THREE.Mesh( this.plane_geometry, this.plane_material );
				
					scene.add(this.plane);
				};

				run = (vector) =>{
					this.plane.position.set(vector.x,vector.y,vector.z);
				}

			}

			


			function render(){

			//FIND INTERSECTION
			
			camera.updateMatrixWorld();

			raycaster.setFromCamera( mouse, camera );
			
			// var vector = pointsClouds.geometry.vertices[1000].clone();
			// vector.applyMatrix4( pointsClouds.matrixWorld );

	
			var intersects = raycaster.intersectObjects( pC );

			
			

			if ( intersects.length > 0 ) {

					intersected = Array.from(intersects);
					let FIRST = intersected[0];
					console.log(FIRST.index);
					RUNNING_INDEXES.indexOf(FIRST.index) == -1 ? (
																	RUNNING_INDEXES.push(FIRST.index),
																	AVATARS.push(new PlaneAvatar(FIRST.index)),
																	console.log(FIRST.index)
																  )
															  : void null;


					
					// plane.position.set(intersected[0].point.x,intersected[0].point.y,intersected[0].point.z)
					// console.log(plane);



					// console.log(intersected[0].point)

					// for (let i = 0; i < intersected.length; i++) {
					// 	intersected[i].object.material.color.set( 0xff0000 );
					// 	console.log(intersected[i].index)
						
					// }

					// console.log(intersected)
					
					// if ( intersected != intersects[ 0 ].object ) {
						
					// 	// console.log(intersects[0].object)
					// 	// if ( intersected ) intersected.material.emissive.setHex( intersected.currentHex );
					// 	// intersected = intersects[ 0 ].object;
					// 	// intersected.currentHex = intersected.material.emissive.getHex();
					// 	// intersected.material.emissive.setHex( 0xff0000 );
					// }
			} 
			else {
					
					if ( intersected ) intersected.map((i,j)=>{i.object.material.color.set( 0x00afaf );})

					// intersects[0].object.material.color.set( 0xff0000 );
					intersected = null;
			};


			AVATARS.map((i)=>
				i.run(ConvertToWorld(i.index))
			);


			renderer.render( scene, camera );

			};



		</script>
	</body>
</html>