<html>
	<head>
		<title>Soul Sphere</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="engine/three.js"></script>
		<script src="engine/libs/OrbitControls.js"></script>
		<script>
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 100, window.innerWidth/window.innerHeight, 0.1, 1000 );

			// var controls = new THREE.OrbitControls( camera );

			var mouseX = 0;
			var mouseY = 0;

			var windowX = window.innerWidth / 2;
			var windowY = window.innerHeight / 2;

			document.addEventListener( 'mousemove', onDocumentMouseMove, false )

			var renderer = new THREE.WebGLRenderer({ antialias : true });
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			//light
			var lights = [];
			lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[ 0 ].position.set( 0, 200, 0 );
			scene.add( lights[ 0 ] );

			//blackGeo
			var geometry = new THREE.IcosahedronGeometry( 1.97, 3 );
			var meshMaterial = new THREE.MeshBasicMaterial( { color: 'black' } );
			var mesh = new THREE.Mesh( geometry, meshMaterial );

			//wireFrame
			var lineMat = new THREE.LineBasicMaterial({ color: 'white' })
			var geometryWire = new THREE.IcosahedronBufferGeometry( 2, 3 );
			var wireframe = new THREE.WireframeGeometry( geometryWire );
			var line = new THREE.LineSegments( wireframe, lineMat );
			line.material.opacity = 1;
			line.material.transparent = true;

			//points setup
			
			var pointGeo = new THREE.IcosahedronGeometry( 3, 4 )
			var pointMat = new THREE.PointsMaterial({ color : 'white', size : 0.02, });

			pointGeo.vertices.forEach(function(vertex) { 
				vertex.x += (Math.random() - 0.5);
				vertex.y += (Math.random() - 0.5);
				vertex.z += (Math.random() - 0.5);
			 })

			var pointsClouds = new THREE.Points( pointGeo, pointMat, );
			scene.add( line );
			scene.add( mesh, pointsClouds );

			

			camera.position.z = 5;

			var animate = function () {
				requestAnimationFrame( animate );

				mesh.rotation.x += 0.001;
				mesh.rotation.y += 0.001;

				line.rotation.x += 0.001;
				line.rotation.y += 0.001;

				pointsClouds.rotation.x += 0.001;
				pointsClouds.rotation.y += 0.001;

				pointsClouds.geometry.vertices.forEach(function(particle) {
					particle.x += (Math.random() / 500);
					particle.y += (Math.random() / 500);
					particle.z += Math.random() / 500;
				} )

				pointsClouds.geometry.vertices.forEach(function(particle) {
					particle.x -= (Math.random() / 500);
					particle.y -= (Math.random() / 500);
					particle.z -= Math.random() / 500;
				} )
				pointsClouds.geometry.verticesNeedUpdate = true;

				//camera
				camera.position.x += ( mouseX - camera.position.x ) * .05;
				camera.position.y += ( mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );




				renderer.render( scene, camera );
			};

			animate();

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowX ) / 100;
				mouseY = ( event.clientY - windowY ) / 100;

			}

		</script>
	</body>
</html>